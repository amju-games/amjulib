// texturing-gencoords.fx
// Generate spherical tex coords 

uniform extern texture gTex;
sampler TexS = sampler_state
{
    Texture = <gTex>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = LINEAR;
};

// World/View/Projection transformation
uniform extern float4x4 gWVP;

// To correctly transform normals
uniform extern float4x4 gWorldInverseTranspose;

// For specular lighting
uniform extern float4x4 gWorld;

uniform extern float4 gDiffuseMtrl;
uniform extern float4 gDiffuseLight;

uniform extern float4 gAmbientMtrl;
uniform extern float4 gAmbientLight;

uniform extern float4 gSpecularMtrl;
uniform extern float4 gSpecularLight;
uniform extern float gSpecularPower;

// Light direction
uniform extern float3 gLightVecW;

uniform extern float3 gEyePosW;

float4 MyPixelShader(
    float3 normalW : TEXCOORD0, 
    float2 tex0    : TEXCOORD1,
    float3 posW    : TEXCOORD2) : COLOR
{
	// Get texel
	float3 texColor = tex2D(TexS, tex0).rgb;
	
	// Combine texel colour with colour generated by lighting
	//float3 diffuse = c.rgb * texColor;
	
	// Add specular separately 
    //return float4(diffuse + spec.rgb, c.a);

    // Interpolated normal can be non-unit length
    normalW = normalize(normalW);
    
    // Calc vector from vertex to eye pos
    float3 toEye = normalize(gEyePosW - posW);
    
    // Calc reflection vector
    float3 r = reflect(-gLightVecW, normalW);
    
    // Calc how much specular light reaches eye
    float t = pow(max(dot(r, toEye), 0.0f), gSpecularPower);
    float3 spec = t * (gSpecularMtrl * gSpecularLight).rgb;
    
    // Calc diffuse colour
    float s = max(dot(gLightVecW, normalW), 0.0f);
    float3 diffuse = s * (gDiffuseMtrl * gDiffuseLight).rgb;
    diffuse *= texColor;
    
    // Calc ambient
    float3 ambient = (gAmbientMtrl * gAmbientLight).rgb;
    
    // Sum components to get final colour
    return float4(diffuse + ambient + spec, gDiffuseMtrl.a);
}

// Vertex info, returned from Vertex Shader
struct MyVert
{
    float4 posH    : POSITION0;
    float3 normalW : TEXCOORD0;
    float2 tex0    : TEXCOORD1;
    float3 posW    : TEXCOORD2;
};

MyVert MyVertexShader(
    float3 posL : POSITION0, 
    float3 normalL : NORMAL0)
{
    MyVert v = (MyVert)0;
    
    // Transform normal to world space
    v.normalW = mul(float4(normalL, 0.0f), gWorldInverseTranspose).xyz;
    v.normalW = normalize(v.normalW);
    
    // Transform vertex pos to world space
    v.posW = mul(float4(posL, 1.0f), gWorld).xyz;
            
    // Transform pos by World/View/Projection (modelview * projection) matrix
    v.posH = mul(float4(posL, 1.0f), gWVP);
    
    // Calc spherical tex coords - see Luna book p. 299
    // TODO There is some texture badness - mipmap issue ?
    float theta = atan2(posL.z, posL.x);
    float mag = sqrt(posL.x*posL.x + posL.y*posL.y + posL.z*posL.z);
    float phi = acos(posL.y / mag);
    // Extra precision doesn't seem to have a noticeable effect
    float pi = 3.14;
    float mult = 0.25f;
    
    v.tex0.x = theta / (mult * 2.0f * pi);
    v.tex0.y = phi / (mult * pi);
    
    return v;
}

technique myTechnique
{
    pass Pass0
    {        
        VertexShader = compile vs_2_0 MyVertexShader();
        PixelShader = compile ps_2_0 MyPixelShader();
        //FillMode = Wireframe;
    }
}

